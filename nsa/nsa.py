
# This file was *autogenerated* from the file nsa.sage
from sage.all_cmdline import *   # import sage library

_sage_const_3 = Integer(3); _sage_const_2 = Integer(2); _sage_const_1 = Integer(1); _sage_const_0 = Integer(0); _sage_const_4 = Integer(4); _sage_const_163 = Integer(163); _sage_const_16 = Integer(16); _sage_const_1728 = Integer(1728); _sage_const_262537412640768000 = Integer(262537412640768000)
import struct
import os

def r(j, k):
    return int(os.urandom(k.nbits()).encode("hex"), _sage_const_16 ) % (k - j) + j

def gen(nbits):
    j = -_sage_const_262537412640768000 
    D = _sage_const_163 
    t = _sage_const_1 

    nb = ((_sage_const_2  ** nbits) // D).nbits() // _sage_const_2  + _sage_const_2 

    while True:
        s = r(_sage_const_2 **(nb - _sage_const_1 ), _sage_const_2 **(nb)) | _sage_const_1 
        p = (D * s**_sage_const_2  + t**_sage_const_2 )

        if p % _sage_const_4  != _sage_const_0 :
            continue

        p = p // _sage_const_4 

        # print "p = {}".format(p)

        if is_prime(p) and p.nbits() == nbits:
            # print "found p = {}".format(p)
            break

    k = Mod(Mod(j, p) * inverse_mod(_sage_const_1728  - j, p), p)
    A = _sage_const_3  * k
    B = _sage_const_2  * k

    E = EllipticCurve(GF(p), [A, B])
    N = E.order()

    if N != p:
        # print "twisting..."
        while True:
            c = r(_sage_const_1 , p)
            if power_mod(c, (p - _sage_const_1 ) // _sage_const_2 , p) != _sage_const_1 :
                break
        A = A * c**_sage_const_2 
        B = B * c**_sage_const_3 
        E = EllipticCurve(GF(p), [A, B])

    assert E.order() == p

    n = r(_sage_const_2  ** (nbits - _sage_const_1 ), p)
    P = E.gens()[_sage_const_0 ]
    Q = n * P
    return (A, B, P, Q, p)

